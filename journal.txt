JAVASCRIPT HANDBOOK

// GET UNIQUE VALUES OF AN ARRAY
var j = [...new Set([1, 2, 3, 3])]
>> [1, 2, 3]

// FIND THE DIFF ELEMENT

const elementDiff = (arr1, arr2) => {
	const newAr = new Set(arr1)
	return arr1.filter(arr => !newAr.has(arr)))	
}

var heroes = ['Batman','Flash','Superman','Wolverine']
var justiceLeaque = elementDiff(heroes, ['Wolverine']);
console.log(justiceLeaque);
Output -->
[ 'Batman', 'Flash', 'Superman' ]

// FILTER BOOLEAN
To Filter Falsy values (0, null, undefined, null, false)
so this trick:
>> myArray
    .map(item => {
        // ...
    })
    // Get rid of bad values
    .filter(Boolean);
	=> the boolean values will be blowed away

// CREATE EMPTY OBJECT
let dict = Object.create(null);

// DICT.__PROTO__ === "UNDEFINED"
// NO OBJECT PROPERTIES EXIST UNTIL YOU 

// MERGE OBJECTS
const person = { name: 'David Walsh', gender: 'Male' };
const tools = { computer: 'Mac', editor: 'Atom' };
const attributes = { handsomeness: 'Extreme', hair: 'Brown', eyes: 'Blue' };

const summary = {...person, ...tools, ...attributes};
/*
Object {
  "computer": "Mac",
  "editor": "Atom",
  "eyes": "Blue",
  "gender": "Male",
  "hair": "Brown",
  "handsomeness": "Extreme",
  "name": "David Walsh",
}
*/
// GET QUERY STRING PARAMETER
URLSearchParams
var urlParams = new URLSearchParams(window.location.search);

console.log(urlParams.has('post')); // true
console.log(urlParams.get('action')); // "edit"
console.log(urlParams.getAll('action')); // ["edit"]
console.log(urlParams.toString()); // "?post=1234&action=edit"
console.log(urlParams.append('active', '1')); // "?post=1234&action=edit&active=1"

// SHORT-CIRCUIT EVALUATION

return (foo || []).length;

If the variable foo is truthy, it will be returned. Otherwise, the length of the empty array will be returned: 0 .

return (this.state.data || 'Fetching Data');

// CONVERT TO STRING

const val = 1 + "";
console.log(val); // Result: "1"
console.log(typeof val); // Result: "string"

// QUICK FLOAT TO INTEGER

console.log(23.9 | 0);  // Result: 23
console.log(-23.9 | 0); // Result: -23

//GET THE LAST ITEM(S) IN AN ARRAY

let array = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];
CONSOLE.LOG(ARRAY.SLICE(-1)); // RESULT: [9]
CONSOLE.LOG(ARRAY.SLICE(-2)); // RESULT: [8, 9]
CONSOLE.LOG(ARRAY.SLICE(-3)); // RESULT: [7, 8, 9]

// SPLICE AND SPLICE AND SPLIT

SPLICE IS MUTABLE METHOD
arr = [1, 2, 3, 1]
example: arr.splice(1, arr.length - 1)
=> arr: [2, 3, 1]
add element syntax: array.splice(index, number of elements, element)
delete element syntax: array.splice(index, number of elements)

SLICE IS IMMUTABLE METHOD
arr  = [1, 2, 3, 1, 2]
example: let newArr = arr.slice(0, 3)
=> newArr: [1, 2, 3], arr: [1, 2, 3, 1, 2]

SPLIT 
SPLIT IS IMMUTABLE METHOD
SPLIT IS SPLIT STRING INTO SUBSTRINGS AND RETURN IT AS A ARRAy

FOREACH , MAP

FOREACH IS MUTABLE METHOD
MAP IS IMMUTABLE METHOD

// DELETE ELEMENT IN ARRAY

let index = arr.indexOf(val)

index > 1 && arr.splice(index, 1)

const deviceName = person?.device?.name;

// MERGE ARRAY 

const arr1 = [1, 2, 3]
const arr2 = [4,5,6]
const array = [...arr1,...arr2]

let newArray = Array(3).fill('')
console.log(newArray) => ['', '', '']

//REACT 
this.setState({ // set state }, () => {execute function here or this is call back})
._lodash
._pickBy(data, ._identity) => this is lodash'method is eleminate all falsy value in data

// SUBSTRING
array.substring(start, end) => (not include end index)
example: req.file.path : public\uploads\b14c9d87c7455a6768ffea73c19d6e32
let fileurl = req.file.path.replace(/\\/g, "/") => public/uploads/b14c9d87c7455a6768ffea73c19d6e32
fileurl.substrings("public".length)

// CACHE

// PROGRESSIVE WEB APP

// PAGINATION SUMMARY

CHECKING EXISTENT PROPERTIES IN 2020

function getAppleExpirationDate(obj) {
  if (food.fruits && food.fruits.apple && food.fruits.apple.dates) {
    return food.fruits.apple.dates.expired
  }
}

==> BETTER WAY

function getAppleExpirationDate(obj) {
  return food?.fruits?.apple?.dates?.expired
}

// EVERY METHOD ARRAY
 const arr = [1,2,3,4,5,6,7,8,9,10]
 arr.every(n => n > 6) => false
 arr.every(n => n > 0) => true
 
 const withtab = JSON.stringify(example, ["student", "firstName", "lastName"], '\t')
 
 ==> this is result
 
 "student" : [
	{
		"firstName": "Tom",
		"lastName": "Hank"
	},
	{
		"firstName": "Ryan",
		"lastName": "Gosling"
	}
 ]
 
 distance between days
 let a= moment()
 let b= moment()
 a.dff(b, "days")
 // 
 let objectA = {
	'name': 'AN',
 }
 
 Object.keys(objectA) => ['name']
 
 // prevent click
 
 onClick = (event) => {
	event.stopPropagation()
 } 
 
 // Concat with conditions
 
 let [productstock, countProductstock, countTotal] = await Promise.all([
      sails.sendNativeQuery(this.req, PRODUCT_STOCK_SQL),
      sails.sendNativeQuery(this.req, COUNT_PRODUCT_SQL)
    ].concat((limit && skip === 0 ? [sails.sendNativeQuery(this.req, TOTAL_PRODUCT_STOCK_SQL)] : [])))

//Example SQL with add, select and where conditions

ALTER TABLE `stock` ADD (
  `newStockId` double DEFAULT NULL,
  `currentStockId` double DEFAULT NULL
); => add column into table `stock`

set @newStockId = (select id from `stock` where `deletedAt` = 0 limit 1);
update `stock` set newStockId = @newStockId where newStockId is null and deletedAt <> 0;
update `stock` set currentStockId = @newStockId where currentStockId is null and deletedAt <> 0;
=> set update with conditions and temp value

// includes method javascript - lodash

syntax: _.includes(collection, value, [fromIndex=0])

Example

_.includes([1, 2, 3], 1);
// => true
 
_.includes([1, 2, 3], 1, 2);
// => false
 
_.includes({ 'a': 1, 'b': 2 }, 1);
// => true
 
_.includes('abcd', 'bc');
// => true

// Convert string array into Array

Example:

let stringArray = "[1, 2]"

string array => array

let realArray = JSON.parse(stringArray)

FILTER TWO ARRAY WITH COMMONS VALUES

var array1 = ['apples', 'grapes', 'oranges', 'banana'],
  array2 = ['potato', 'pears', 'grapes', 'berries', 'apples', 'oranges'];

var intersection = array1.filter(function(e) {
  return array2.indexOf(e) > -1;
});

console.log(intersection);
Trivia notes:

EVERYTHING CREATED IN JAVASCRIPT IS EITHER A PRIMITIVE OR AN OBJECT. THEREFORE, IF IT ISN'T ONE OF THOSE SEVEN PRIMITIVES, SO IT'S AN OBJECT

// OBJECT FROM ENTRIES

const keyValuePair = [
  ['cow', 'Bo'],
  ['pig', 'Heo'],
];

Object.fromEntries(keyValuePair); => result: // { cow: Bo pig: Heo }

const map = new Map([
  ['key 1', 'value 1'],
  ['key 2', 'value 2'],
]);

// USING THE CONSTRUCTOR
const map = new Map([
  ['key 1', 'value 1'],
  ['key 2', 'value 2'],
]);
// OR WE CAN USE THE INSTANCE METHOD, "SET"
const map = new Map();
map.set('key 1', 'value 1');
map.set('key 2', 'value 2');
// RESULT
// Map(2) {"key 1" => "value 1", "key 2" => "value 2"}

OBJECT.FROMENTRIES(MAP) => // { KEY 1: "VALUE 1", KEY 2: "VALUE 2"}
MAKE SURE YOU ONLY PASS A KEY-VALUE PAIR 

Object.fromEntries vs Object.entries

const object = { key1: 'value1', key2: 'value2' };
const array = Object.entries(object);
// [ ["key1", "value1"], ["key2", "value2"] ]
Object.fromEntries(array);
// { key1: 'value1', key2: 'value2' }

const food = { meat: 'ðŸ¥©', broccoli: 'ðŸ¥¦', carrot: 'ðŸ¥•' };
// ðŸ˜„ Yay, still in Object land
const vegetarian = Object.fromEntries(
  Object.entries(food).filter(([key, value]) => key !== 'meat'),
);
// { broccoli: 'ðŸ¥¦', carrot: 'ðŸ¥•' }

// NULLISH COALESCING

false ?? "default string"
=> result: false

NaN ?? "default string"
=> result: NaN

0 ?? "default string"
=> 0

null ?? "default string"
=> "default string"

undefined ?? "default string"
=> "default string" 

String#matchAll

const regexp = /[a-c]/g
const str = 'ab'
const iterator = str.matchAll(regexp)

Array.from(iterator, result => console.log(result))

=> ["a", index: 0, input: "abc", group: undefined ]

=> ["b", index: 1, input: "abc", group: undefined ]






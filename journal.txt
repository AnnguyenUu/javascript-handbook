JAVASCRIPT HANDBOOK

// GET UNIQUE VALUES OF AN ARRAY
var j = [...new Set([1, 2, 3, 3])]
>> [1, 2, 3]

// Create New Array 

// Alternative declaration
names = new Array('Mike', 'Paul', 'John')

// More efficiently store in a array
names = ['Mike', 'Paul', 'John']

// FIND THE DIFF ELEMENT

const elementDiff = (arr1, arr2) => {
	const newAr = new Set(arr1)
	return arr1.filter(arr => !newAr.has(arr)))	
}

var heroes = ['Batman','Flash','Superman','Wolverine']
var justiceLeaque = elementDiff(heroes, ['Wolverine']);
console.log(justiceLeaque);
Output -->
[ 'Batman', 'Flash', 'Superman' ]

// FILTER BOOLEAN
To Filter Falsy values (0, null, undefined, null, false)
so this trick:
>> myArray
    .map(item => {
        // ...
    })
    // Get rid of bad values
    .filter(Boolean);
	=> the boolean values will be blowed away

// CREATE EMPTY OBJECT
let dict = Object.create(null);

// DICT.__PROTO__ === "UNDEFINED"
// NO OBJECT PROPERTIES EXIST UNTIL YOU 

// MERGE OBJECTS
const person = { name: 'David Walsh', gender: 'Male' };
const tools = { computer: 'Mac', editor: 'Atom' };
const attributes = { handsomeness: 'Extreme', hair: 'Brown', eyes: 'Blue' };

const summary = {...person, ...tools, ...attributes};
/*
Object {
  "computer": "Mac",
  "editor": "Atom",
  "eyes": "Blue",
  "gender": "Male",
  "hair": "Brown",
  "handsomeness": "Extreme",
  "name": "David Walsh",
}
*/
// GET QUERY STRING PARAMETER
URLSearchParams
var urlParams = new URLSearchParams(window.location.search);

console.log(urlParams.has('post')); // true
console.log(urlParams.get('action')); // "edit"
console.log(urlParams.getAll('action')); // ["edit"]
console.log(urlParams.toString()); // "?post=1234&action=edit"
console.log(urlParams.append('active', '1')); // "?post=1234&action=edit&active=1"

// SHORT-CIRCUIT EVALUATION

return (foo || []).length;

If the variable foo is truthy, it will be returned. Otherwise, the length of the empty array will be returned: 0 .

return (this.state.data || 'Fetching Data');

// CONVERT TO STRING

const val = 1 + "";
console.log(val); // Result: "1"
console.log(typeof val); // Result: "string"

// QUICK FLOAT TO INTEGER

console.log(23.9 | 0);  // Result: 23
console.log(-23.9 | 0); // Result: -23

//GET THE LAST ITEM(S) IN AN ARRAY

let array = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];
CONSOLE.LOG(ARRAY.SLICE(-1)); // RESULT: [9]
CONSOLE.LOG(ARRAY.SLICE(-2)); // RESULT: [8, 9]
CONSOLE.LOG(ARRAY.SLICE(-3)); // RESULT: [7, 8, 9]

// SPLICE AND SPLICE AND SPLIT

SPLICE IS MUTABLE METHOD
arr = [1, 2, 3, 1]
example: arr.splice(1, arr.length - 1)
=> arr: [2, 3, 1]
add element syntax: array.splice(index, number of elements, element)
delete element syntax: array.splice(index, number of elements)

SLICE IS IMMUTABLE METHOD
arr  = [1, 2, 3, 1, 2]
example: let newArr = arr.slice(0, 3)
=> newArr: [1, 2, 3], arr: [1, 2, 3, 1, 2]

SPLIT 
SPLIT IS IMMUTABLE METHOD
SPLIT IS SPLIT STRING INTO SUBSTRINGS AND RETURN IT AS A ARRAy

FOREACH , MAP

FOREACH IS MUTABLE METHOD
MAP IS IMMUTABLE METHOD

// DELETE ELEMENT IN ARRAY

let index = arr.indexOf(val)

index > 1 && arr.splice(index, 1)

const deviceName = person?.device?.name;

// MERGE ARRAY 

const arr1 = [1, 2, 3]
const arr2 = [4,5,6]
const array = [...arr1,...arr2]

let newArray = Array(3).fill('')
console.log(newArray) => ['', '', '']

//REACT 
this.setState({ // set state }, () => {execute function here or this is call back})
._lodash
._pickBy(data, ._identity) => this is lodash'method is eleminate all falsy value in data

// SUBSTRING
array.substring(start, end) => (not include end index)
example: req.file.path : public\uploads\b14c9d87c7455a6768ffea73c19d6e32
let fileurl = req.file.path.replace(/\\/g, "/") => public/uploads/b14c9d87c7455a6768ffea73c19d6e32
fileurl.substrings("public".length)

// CACHE

// PROGRESSIVE WEB APP

// PAGINATION SUMMARY

CHECKING EXISTENT PROPERTIES IN 2020

function getAppleExpirationDate(obj) {
  if (food.fruits && food.fruits.apple && food.fruits.apple.dates) {
    return food.fruits.apple.dates.expired
  }
}

==> BETTER WAY

function getAppleExpirationDate(obj) {
  return food?.fruits?.apple?.dates?.expired
}

// EVERY METHOD ARRAY
 const arr = [1,2,3,4,5,6,7,8,9,10]
 arr.every(n => n > 6) => false
 arr.every(n => n > 0) => true
 
 const withtab = JSON.stringify(example, ["student", "firstName", "lastName"], '\t')
 
 ==> this is result
 
 "student" : [
	{
		"firstName": "Tom",
		"lastName": "Hank"
	},
	{
		"firstName": "Ryan",
		"lastName": "Gosling"
	}
 ]
 
 distance between days
 let a= moment()
 let b= moment()
 a.dff(b, "days")
 // 
 let objectA = {
	'name': 'AN',
 }
 
 Object.keys(objectA) => ['name']
 
 // prevent click
 
 onClick = (event) => {
	event.stopPropagation()
 } 
 
 // Concat with conditions
 
 let [productstock, countProductstock, countTotal] = await Promise.all([
      sails.sendNativeQuery(this.req, PRODUCT_STOCK_SQL),
      sails.sendNativeQuery(this.req, COUNT_PRODUCT_SQL)
    ].concat((limit && skip === 0 ? [sails.sendNativeQuery(this.req, TOTAL_PRODUCT_STOCK_SQL)] : [])))

//Example SQL with add, select and where conditions

ALTER TABLE `stock` ADD (
  `newStockId` double DEFAULT NULL,
  `currentStockId` double DEFAULT NULL
); => add column into table `stock`

set @newStockId = (select id from `stock` where `deletedAt` = 0 limit 1);
update `stock` set newStockId = @newStockId where newStockId is null and deletedAt <> 0;
update `stock` set currentStockId = @newStockId where currentStockId is null and deletedAt <> 0;
=> set update with conditions and temp value

// includes method javascript - lodash

syntax: _.includes(collection, value, [fromIndex=0])

Example

_.includes([1, 2, 3], 1);
// => true
 
_.includes([1, 2, 3], 1, 2);
// => false
 
_.includes({ 'a': 1, 'b': 2 }, 1);
// => true
 
_.includes('abcd', 'bc');
// => true

// Convert string array into Array

Example:

let stringArray = "[1, 2]"

string array => array

let realArray = JSON.parse(stringArray)

FILTER TWO ARRAY WITH COMMONS VALUES

var array1 = ['apples', 'grapes', 'oranges', 'banana'],
  array2 = ['potato', 'pears', 'grapes', 'berries', 'apples', 'oranges'];

var intersection = array1.filter(function(e) {
  return array2.indexOf(e) > -1;
});

console.log(intersection);
Trivia notes:

EVERYTHING CREATED IN JAVASCRIPT IS EITHER A PRIMITIVE OR AN OBJECT. THEREFORE, IF IT ISN'T ONE OF THOSE SEVEN PRIMITIVES, SO IT'S AN OBJECT

// OBJECT FROM ENTRIES

const keyValuePair = [
  ['cow', 'Bo'],
  ['pig', 'Heo'],
];

Object.fromEntries(keyValuePair); => result: // { cow: Bo pig: Heo }

const map = new Map([
  ['key 1', 'value 1'],
  ['key 2', 'value 2'],
]);

// USING THE CONSTRUCTOR
const map = new Map([
  ['key 1', 'value 1'],
  ['key 2', 'value 2'],
]);
// OR WE CAN USE THE INSTANCE METHOD, "SET"
const map = new Map();
map.set('key 1', 'value 1');
map.set('key 2', 'value 2');
// RESULT
// Map(2) {"key 1" => "value 1", "key 2" => "value 2"}

OBJECT.FROMENTRIES(MAP) => // { KEY 1: "VALUE 1", KEY 2: "VALUE 2"}
MAKE SURE YOU ONLY PASS A KEY-VALUE PAIR 

Object.fromEntries vs Object.entries

const object = { key1: 'value1', key2: 'value2' };
const array = Object.entries(object);
// [ ["key1", "value1"], ["key2", "value2"] ]
Object.fromEntries(array);
// { key1: 'value1', key2: 'value2' }

const food = { meat: '🥩', broccoli: '🥦', carrot: '🥕' };
// 😄 Yay, still in Object land
const vegetarian = Object.fromEntries(
  Object.entries(food).filter(([key, value]) => key !== 'meat'),
);
// { broccoli: '🥦', carrot: '🥕' }

// NULLISH COALESCING

false ?? "default string"
=> result: false

NaN ?? "default string"
=> result: NaN

0 ?? "default string"
=> 0

null ?? "default string"
=> "default string"

undefined ?? "default string"
=> "default string" 

String#matchAll

const regexp = /[a-c]/g
const str = 'ab'
const iterator = str.matchAll(regexp)

Array.from(iterator, result => console.log(result))

=> ["a", index: 0, input: "abc", group: undefined ]

=> ["b", index: 1, input: "abc", group: undefined ]

// 
<input type="checkbox" id="check_me" ref="checked_now" />

GET VALUE OF THIS INPUT FROM ANOTHER DOM

example

let a = this.refs.checked_now.checked (this.refs.checked_now.value)

GET VALUE THROUGH GETELEMENTBYID

<input type="text" id="text_me" ref="text-box" />

let text = document.getElementbyID("text_me").value

UPDATE VALUE THROUGH GETELEMENTBYID

<input type="checkbox" id="check_me" ref="checked_now" />

document.getElementbyID("check_me").checked = true 

OR

document.getElementbyID("check_me").checked = false

CHECK NULL VALUE

let bar = null 

console.log(Array.isArray(bar));

CLOSURE Example: 

for (var i = 0; i < 5; i++) {
	setTimeout(function() { console.log(i); }, i * 1000 );
}

=> result is 5, 5, 5, 5

for (let i = 0; i < 5; i++) {
	setTimeout(function() { console.log(i); }, i * 1000 );
}

=> result is 0, 1, 2, 3, 4

JavaScript currently has eight data types:

number
bigint
string
boolean
null
undefined
object
symbol

Querying the DOM

document.getElementsByClassName('class name')
document.querySelectorAll('.class name')

// CLOSURE Example:  (continue)

function showName (first, last) {
    let name = "my name is ";
    let asd = 'asd'
    function fullName() { ==> this is inner function
        console.log(asd); ==> variable from outer function
        console.log(name + first + " " + last) 
    }
    return fullName()
}

showName('an', 'nguyen')

ASYNCHRONOUS

An asynchronous model allows multiple things to happen at the same time. When you start an action, your program continues to run.
When the action finishes, the program is informed and gets access to the result (for example, the data read from disk).

DIFFERENCE BETWEEN PROMISE AND ASYNC/AWAIT

ASYNC/AWAIT makes your code leaner and fresher

PROMISE
const makeRequest = () => {
  return getJSON()
    .then(data => {
      if (data.needsAnotherRequest) {
        return makeAnotherRequest(data)
          .then(moreData => {
            console.log(moreData)
            return moreData
          })
      } else {
        console.log(data)
        return data
      }
    })
} ===> have 6 level nested together => look like hell

ASYNC/AWAIT

const makeRequest = async () => {
  const data = await getJSON()
  if (data.needsAnotherRequest) {
    const moreData = await makeAnotherRequest(data);
    console.log(moreData)
    return moreData
  } else {
    console.log(data)
    return data    
  }
} ==> cleaner and easy to debug

EASY to debug with ASYNC/AWAIT

can't set break point into promise function

example

const makeExample = () => {
	return allPromiseApi()
		.then(() => allPromiseApi)
		.then(() => allPromiseApi)
		.then(() => allPromiseApi)
		.then(() => allPromiseApi)
} ==> debug is become impossible

Break point with ASYNC/AWAIT too easy

DATA STUCTURE IN JAVASCRIPT

Queues
=> FIFO: First In First Out

Stack
=> FILO: First In Last Out

Trees

Graphs

Hash Map

REDUX

Data flow of application is too complicated

Use for Component interact each other, not parent/child Component

LOCAL STORAGE VS SESSION STORAGE VS COOKIE

LOCAL STORAGE

- LocalStorage is a way to store data on the client’s computer.
- It allows the saving of key/value pairs in a web browser and it stores data with no expiration date.
- However, the user has the ability to clear the browser data/cache to erase all localStorage data.
- Data is never transferred to the server

SESSION STORAGE

- Stores data only for a session, meaning that the data is stored until the browser (or tab) is closed
- Data is never transferred to the server
- Can only be read on client-side
- Storage limit is about 5-10MB
- Opening multiple tabs/windows with the same URL creates sessionStorage for each tab/window

COOKIE

- Cookies are primarily for server-side reading (can also be read on client-side), localStorage and sessionStorage can only be read on client-side.
- Size must be less than 4KB.
- Cookies can be made secure by setting the httpOnly flag as true for that cookie. This prevents client-side access to that cookie.
- Can read, write, delete with document.cookie

WHAT’S THE DIFFERENCE BETWEEN UNDEFINED AND NULL?

undefined is the value for undeclared variables

null equals undefined when compared with the == operator . => this is all falsy
They aren’t equal when we compare them with the === operator since they’re of different types.

STATE 

The state is a data structure that starts with a default value when a Component mounts. It may be mutated across time, mostly as a result of user events

PROPS

Props (short for properties) are a Component’s configuration. Props are how components talk to each other.
They are received from above component and immutable as far as the Component receiving them is concerned.
Props do not have to just be data — callback functions may be passed in as props.

PROPS and STATE do similar things but are used in different ways. The majority of our components will probably be stateless. 
Props are used to pass data from parent to child or by the component itself.
They are immutable and thus will not be changed. State is used for mutable data, or data that will change.
This is particularly useful for user input.

maxItemOfArray

const maxItemOfArray = (arr) => […arr].sort((a, b) => b — a).slice(0, 1)[0];
let maxItem = maxItemOfArray([3, 5, 12, 5]);

areAllEqual

const areAllEqual = array => array.every(item => item === array[0]);
let check1 = areAllEqual([3, 5, 2]); // false
let check2 = allEqual([3, 3, 3]); // true

averageOf

const averageOf = (…numbers) => numbers.reduce((a, b) => a + b, 0) / numbers.length;
let average = averageOf(5, 2, 4, 7); // 4.5

findAndReplace

const findAndReplace = (string, wordToFind, wordToReplace) => string.split(wordToFind).join(wordToReplace);
let result = findAndReplace(‘I like banana’, ‘banana’, ‘apple’); // I like apple




removeDuplicatedValues

const removeDuplicatedValues = array => […new Set(array)];
let arr = removeDuplicatedValues([5, 3, 2, 5, 6, 1, 1, 6]); // [5, 3, 2, 6, 1]

getTimeFromDate

const getTimeFromDate = date => date.toTimeString().slice(0, 8);
let time = getTimeFromDate(new Date()); // 09:46:08

capitalizeAllWords

const capitalizeAllWords = str => str.replace(/\b[a-z]/g, char => char.toUpperCase());
let str = capitalizeAllWords(‘i love reading book’); // I Love Reading Book

LODASH

	1. _.assign

	var foo = { a: "a property" };
	var bar = { b: 4, c: "an other property" }

	var result = _.assign({ a: "an old property" }, foo, bar);
	// result => { a: 'a property', b: 4, c: 'an other property' }

	2. _.times

	function getRandomInteger() {
		return Math.round(Math.random() * 100);
	}

	var result = _.times(5, getRandomNumber);
	// result => [64, 70, 29, 10, 23]

	3. _.debounce

	function validateEmail() {
		// Validate email here and show error message if not valid
	}

	var emailInput = document.getElementById("email-field");
	emailInput.addEventListener("keyup", _.debounce(validateEmail, 500));

	4. _.find


	var users = [
	  { firstName: "John", lastName: "Doe", age: 28, gender: "male" },
	  { firstName: "Jane", lastName: "Doe", age: 5, gender: "female" },
	  { firstName: "Jim", lastName: "Carrey", age: 54, gender: "male" },
	  { firstName: "Kate", lastName: "Winslet", age: 40, gender: "female" }
	];

	var user = _.find(users, { lastName: "Doe", gender: "male" });
	// user -> { firstName: "John", lastName: "Doe", age: 28, gender: "male" }

	var underAgeUser = _.find(users, function(user) {
		return user.age < 18;
	});
	// underAgeUser -> { firstName: "Jane", lastName: "Doe", age: 5, gender: "female" }

	5. _.get and ._set
		
	var bar = { foo: { key: "foo" } };
	_.set(bar, "foo.items[0]", "An item");
	// bar => { foo: { key: "foo", items: ["An item"] } }
	var name = _.get(bar, "name", "John Doe");
	// name => John Doe
	
	6. _.deburr
	
	_.deburr("déjà vu");
	// -> deja vu
	_.deburr("Juan José");
	// -> Juan Jose	
	
	7. _.keyBy
	
	var posts = [
    { id: "1abc", title: "First blog post", content: "..." },
    { id: "2abc", title: "Second blog post", content: "..." },
    // more blog posts
    { id: "34abc", title: "The blog post we want", content: "..." }
    // even more blog posts
	];

	posts = _.keyBy(posts, "id");

	var post = posts["34abc"]
	// post -> { id: "34abc", title: "The blog post we want", content: "..." }
	
	8. _.reduce
	
	var users = [
    { name: "John", age: 30 },
    { name: "Jane", age: 28 },
    { name: "Bill", age: 65 },
    { name: "Emily", age: 17 },
    { name: "Jack", age: 30 }
	]

	var reducedUsers = _.reduce(users, function (result, user) {
		if(user.age >= 18 && user.age <= 59) {
			(result[user.age] || (result[user.age] = [])).push(user);
		}
	  
		return result;
	}, {});

	// reducedUsers -> { 
	//     28: [{ name: "Jane", age: 28 }], 
	//     30: [{ name: "John", age: 30 }, { name: "Jack", age: 30 }] 
// }
	
	9. _.cloneDeep
	
	var original = { foo: "bar" };
	var copy = original;
	copy.foo = "new value";
	// copy -> { foo: "new value" } Yeah!
	// original -> { foo: "new value" } Oops!

	var original = { foo: "bar" };
	var copy = _.cloneDeep(original);
	copy.foo = "new value";
	// copy -> { foo: "new value" } Yeah!
	// original -> { foo: "bar" } Yeah!
	
	10 _. sortedUniq
		
	var sortedArray = [1, 1, 2, 3, 3, 3, 5, 8, 8];
	var result = _.sortedUniq(sortedArray);
	// -> [1, 2, 3, 5, 8]
	
High-Order Function

let colors = ["red", "green", "blue"]

colors.forEach(myFavColor)

function myFavColor(color) {
	console.log(`the color ${color} is my favorite color`)
}

CONVERT Falsy VALUE

!!null => false
!!undefined => false
!!NaN => false
!! "      " => false

REACT COMPONENT LIFECYCLE

constructor => getDerivedStateFromProps => render => componentDidMount => ***lifeCycle

***lifeCycle => getDerivedStateFromProps(nextProps, prevState) (only called when receiving new props return the new state) => *

* => shouldComponentUpdate => componentWillUnMount => render => getSnapshotBeforeUpdate => componentDidUpdate => lifeCycle***

 LIFECYCLE                       ||                   HOOKS
 
 componentDidMount() {      			useEffect(() => { // called only once }, [])
	// component mounted
 }
 
 componentWillUnMount() {				useEffect(() => { // it will be called before unmounting return () => {} }, [])		
	// component unmounted
 }
 
 componentDidUpdate() {                  useEffect(() => { // called every time }) || useEffect(() => { // dependencies}, [dependencies])
	// updated values
 }
 
 shouldComponentUpdate() {               // use React momo
	// should i render again ?
 }
 
 USING INDEXING INSTEAD of SWITCH...CASE
 
 const breeds = {
	'dog': ['Husky', 'Poodle', 'Shiba'],
	'cat': ['Korat', 'Donskoy'],
	'bird': ['Parakeets', 'Canaries']
 }
 
 SWITCH ...CASE
 EX:
	const getBreeds = pet => {
		switch(pet) {
			case 'dog':
				return ['Husky', 'Poodle', 'Shiba'];
			case 'cat':
				return ['Korat', 'Donskoy'];
			case 'bird':
				return ['Parakeets', 'Canaries'];
			default:
				return [];
		}
 };
 
 INDEXING:
 EX: 
	const getBreeds = pet => {
		return breeds[pet] || [];
	}
	
	let dogBreeds = getBreeds('cat'); // ['Korat', 'Donskoy']
 

const moment = require('moment');
let b = "29/10/2020 02:28"
let c = moment(b, 'DD/MM/YYYY HH:mm').format("YYYY-MM-DD HH:mm:ss")
console.log(c) ==> 2020-10-29 02:28:00

SHORT HAND CONTINUE

// Longhand
if(x == 1 || x == 5 || x == 7)  {
  console.log('X has some value');
}
// Shorthand
([1,5,7].indexOf(x) !=- 1) && alert('X has some value!');

Using Lookup Tables

// Longhand
if (hero === 'Robin') {
  callRobin();
}
else if (hero === 'Raven') {
  callRaven();
}
else if (hero === 'Starfire') {
  callStarfire();
}
else if (hero === 'BeastBoy') {
  callBeastBoy();
} else {
  throw new Error('No such hero is available...!!! - ' + type);
}

// Shorthand
var heroNeeded= {
  Robin: callRobin,
  Raven: callRaven,
  Starfire: callStarfire,
  BeastBoy: callBeastBoy
};
 
var func = heroNeeded[hero];
(!func) && throw new Error('Hero not available ' + hero); 
func();

[undefined, "", null].includes(variable) : if variable = undefined or "" or null => is all true 

let num = 15;
let s = num + ""; // number to string
let n = +s; // string to number

let filledArray = new Array(arraysize).fill(null).map(()=> ({'hello' : 'goodbye'}));

Dynamic properties in obj

let dynamic = "value";

let user = {
	id: 1,
	[dynamic]: "other value"
}

Array to Object

let arr = ["value1", "value2", "value3"]; 
let arrObject = {...arr}; 

Object to Array

let number = {
  one: 1, 
  two: 2,
};
let key = Object.keys(numbers); // key = [ 'one', 'two' ]
let value = Object.values(numbers);  // value = [ 1, 2 ]
let entry = Object.entries(numbers); // entry = [['one' : 1], ['two' : 2]]

Check if value is an array

const arr = [1, 2, 3]
console.log(typeof arr); // object
console.log(Array.isArray(arr)) // true

False values => false, 0, ""(empty string), null, undefined, &NaN.

Truthy values => "Values", "0", {}(empty object), &[](empty array).

Find max and min value in array

const priceHistory = [400, 500, 300, 660, 910]

const minimumPrice = Math.min(...priceHistory) // 300

const maximumPrice = Math.max(...priceHistory) // 910

SUPER HACKY

const randomStuff = [5, null, false, -3, '65'];

/* Convert to string */
randomStuff.map(String); // ["5", "null", "false", "-3", "65"]

/* Convert to number */
randomStuff.map(Number); // [5, 0, 0, -3, 65]

/* Filter out falsy values */
randomStuff.filter(Boolean); // [5, -3, "65"]

/* Falsy check */
!randomStuff.every(Boolean); // true

COPY A STRING MULTIPLE TIMES

// Concatenate "ha" 3 times.
const laughing = "ha".repeat(3);
console.log(laughing); // "hahaha"

// Concatenate "1" 8 times.
const eightBits = "1".repeat(8);
console.log(eightBits ); // "11111111"

 PAD A STRING TO A SPECIFIC LENGTH
 
 // Add "0" to the beginning until the string has a length of 8.
const eightBits = "001".padStart(8, "0");
console.log(eightBits); // "00000001"

// Add "*" to the end until the string has a length of 5.
const anonymizedCode = "34".padEnd(5, "*");
console.log(anonymizedCode); // "34***"

SPLIT A STRING INTO AN ARRAY OF CHARACTERS

const word = "apple";
const characters = [...word];
console.log(characters); // ["a", "p", "p", "l", "e"]

COUNT CHARACTERS IN A STRING

const word = "𩸽";
const characters = [...word];
console.log(characters.length) // 1;

CAPITALIZE (UPPERCASE) THE FIRST LETTER IN A STRING

// This shows an alternative way
let word = "apple";

// Use spread operator (`...`) to split into characters.
// Transform first character and join array.
const characters = [...word];
characters[0] = characters[0].toUpperCase();
word = characters.join("");

console.log(word); // "Apple"

SPLIT A STRING ON MULTIPLE SEPARATORS

// Let's split on comma (,) and semicolon (;).
const list = "apples,bananas;cherries"
const fruits = list.split(/[,;]/);
console.log(fruits); // ["apples", "bananas", "cherries"]

CHECK IF A STRING STARTS OR ENDS WITH A SPECIFIC SEQUENCE

const text = "Hello, world! My name is Kai!"

console.log(text.startsWith("Hello")); // true

console.log(text.endsWith("world")); // false

Replace All Occurrences of a String

const text = "I like apples. You like apples."

console.log(text.replace(/apples/g, "bananas"));
// "I like bananas. You like bananas."

console.log(text.replaceAll("apples", "bananas"));
// "I like bananas. You like bananas."

USE MEMO React Hooks

const memoizedValue = useMemo(functionThatReturnsValue, 
                                   arrayDepencies)

MERGE/FLATTEN YOUR ARRAYS IN ARRAYS

const arrays = [[10], 50, [100, [2000, 3000, [40000]]]];
arrays.flat(Infinity);
// [ 10, 50, 100, 2000, 3000, 40000 ]

PREVENTING YOUR CODE CRASH

const found = [{ name: "Alex" }].find(i => i.name === 'Jim') || {};
console.log(found.name);
// undefined

MASK IT NICELY

const password = "hackme";
password.substr(-3).padStart(password.length, "*");
// ***kme

import { clearArray } from './helpers';

const collection = [[], {}, "", null, undefined, NaN, "wee"];
const cleanCollection = collection.filter(clearArray);
//  ["wee"]

GENERATE A LIST WITH RANDOM NUMBERS

Array.from({ length: 1000 }, Math.random)

GENERATE A LIST WITH NUMBERS

Array.from({ length: 1000 }, (v, i) => i)
// [0, 1, 2, 3, 4, 5, 6....999]

const isValidURL = (url) => {
  try {
    new URL(url);
    return true;
  } catch (error) {
    return false;
  }
};

isValidURL("https://dev.to");
// true

isValidURL("https//invalidto");
// false

GENERATE PATH WITH QUERY STRING

const generatePathQuery = (path, obj) =>
  path +
  Object.entries(obj)
    .reduce((total, [k, v]) => (total += `${k}=${encodeURIComponent(v)}&`), "?")
    .slice(0, -1);

generatePathQuery("/user", { name: "Orkhan", age: 30 }); 

// "/user?name=Orkhan&age=30"

const getQueryParams = url =>
  url.match(/([^?=&]+)(=([^&]*))/g).reduce((total, crr) => {
    const [key, value] = crr.split("=");
    total[key] = value;
    return total;
  }, {});

getQueryParams("/user?name=Orkhan&age=30");
// { name: 'Orkhan', age: '30' }
TRY CATCH 
try {
  functionSomeThing();
} catch (error) {
  // Hiện thị error lên realtime
  console.error(error);
  // Nhắc nhở người dùng trên giao diện nếu cần
  notifyUserOfError(error);
  // Save lại lỗi, để xem log mỗi ngày khi ngủ dậy.
  reportErrorToService(error);

}

JAVASCRIPT DOES THIS BECAUSE FOREACH IS NOT PROMISE-AWARE. IT CANNOT SUPPORT ASYNC AND AWAIT. YOU CANNOT USE AWAIT IN FOREACH.

AWAIT WITH MAP

const mapLoop = async _ => {
  console.log('Start')

  const promises = fruitsToGet.map(async fruit => {
    const numFruit = await getNumFruit(fruit)
    return numFruit
  })

  const numFruits = await Promise.all(promises)
  console.log(numFruits)

  console.log('End')
}

const mapLoop = async _ => {
  // ...
  const promises = fruitsToGet.map(async fruit => {
    const numFruit = await getNumFruit(fruit)
    // Adds onn fruits before returning
    return numFruit + 100
  })
  // ...
}

AWAIT WITH FILTER

There are three steps to use await and filter properly:
	1 - Use map to return an array promises
	2 - await the array of promises
	3 - filter the resolved values
	
const filterLoop = async _ => {
  console.log('Start')

  const promises = await fruitsToGet.map(fruit => getNumFruit(fruit))
  const numFruits = await Promise.all(promises)

  const moreThan20 = fruitsToGet.filter((fruit, index) => {
    const numFruit = numFruits[index]
    return numFruit > 20
  })

  console.log(moreThan20)
  console.log('End')
}

AWAIT WITH REDUCE

const reduceLoop = async _ => {
  console.log('Start')

  const promises = fruitsToGet.map(getNumFruit)
  const numFruits = await Promise.all(promises)
  const sum = numFruits.reduce((sum, fruit) => sum + fruit)

  console.log(sum)
  console.log('End')
}

NOTE: getNumFruit is function take a long time

REPLICAN MULTIPLE ARRAY FROM ONE ARRAY-OBJECT

let [pick, assign, reason, categories] = statisticData.reduce(
      (accum, val) => {
          accum[0].push(val.totalBillReceived ?? 0);
          accum[1].push(val.totalBillAssign ?? 0);
          accum[2].push(val.totalBillReason ?? 0);
          accum[3].push(val.bpartnerName || "");
          return accum;
      },
      [ [], [], [], [] ]
  );
SKIP FIRST TIME EFFECT

export const useIsMount = () => {
  const isMountRef = useRef(true);
  useEffect(() => {
    isMountRef.current = false;
  }, []);
  return isMountRef.current;


PROMISE ALLSETTLED

Promise.allSettled([
    Promise.reject('✗'),
    Promise.reject('✗'),
    Promise.resolve('✓'),
    Promise.reject('✗'),
]).then(function(value) {
    console.log(`You win at life`, value)
})

=> result : You win at life,
[
    {
        status:"rejected",
        reason:"✗"
    },
    {
        status:"rejected",
        reason:"✗"
    },
    {
        status:"fulfilled",
        value:"✓"
    },
    {
        status:"rejected",
        reason:"✗"
    }
]
let dogs = [
    { name: ‘Rio’, age: 2 },
    { name: ‘Mac’, age: 3 },
    { name: ‘Bruno’, age: 5 },
    { name: ‘Jucas’, age: 10 },
    { name: ‘Furr’, age: 8 },
    { name: ‘Blu’, age: 7 },
]


let dogsNames = Array.from(dogs, ({name}) => name);
console.log(dogsNames); // returns [“Rio”, “Mac”, “Bruno”, “Jucas”, “Furr”, “Blu”]

Get the Last Items in an ARRAY
let array = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];
console.log(array.slice(-1)); // Result: [9]
console.log(array.slice(-2)); // Result: [8, 9]
console.log(array.slice(-3)); // Result: [7, 8, 9]

Quick Rounding

console.log(23.9 | 0);  // Result: 23
console.log(-23.9 | 0); // Result: -23


Promise.allSettled([
    Promise.reject('✗'),
    Promise.reject('✗'),
    Promise.resolve('✓'),
    Promise.reject('✗'),
]).then(function(value) {
    console.log(`You win at life`, value)
})

Output:

You win at life,
[
    {
        status:"rejected",
        reason:"✗"
    },
    {
        status:"rejected",
        reason:"✗"
    },
    {
        status:"fulfilled",
        value:"✓"
    },
    {
        status:"rejected",
        reason:"✗"
    }
]

const items = ['a', 'b', 'c', 'd', 'e', 'f']
console.log(items.fill('--NEW-ITEM--', 2, 3))

Cú pháp: arr.fill(value[, start[, end]])Với: 



value: Là giá trị cần fill. 
start (Optional): Vị trí bắt đầu fill, mặc định là 0 
end (Optional): Vị trí kết thúc fill, mặc định là this.length

ARRAY findAndRemove() ES6
const list = [
    {id: 1,"name":"anonystick.com"},
    {id: 2,"name":"medium.com"},
    {id: 3,"name":"facebook.com"}
]
console.log(list.findAndRemove(2, "id")); //remove id = 2

ARRAY getIndexes()

const findIndex = [1,2,3,4,3,6,8,3]
console.log(findIndex.getIndexes(3))

Output: [2, 4, 7]

const list = [{name: "anonystick"}, {name: "facebook"}, {name: "anonystick"}]
console.log(list.getIndexes(obj => obj.name === 'anonystick'))

Output: [0, 2]

Array.distinct()

const array = [1, 1, 1, 3, 3, 2, 2]
console.log(array.distinct())
Output: [1, 3, 2]

const arr = [
 { id: 1, name: "king" },
 { id: 2, name: "master" },
 { id: 3, name: "lisa" },
 { id: 4, name: "ion" },
 { id: 5, name: "jim" },
 { id: 6, name: "gowtham" },
 { id: 1, name: "jam" },
 { id: 1, name: "lol" },
 { id: 2, name: "kwick" },
 { id: 3, name: "april" },
 { id: 7, name: "sss" },
 { id: 8, name: "brace" },
 { id: 8, name: "peiter" },
 { id: 5, name: "hey" },
 { id: 6, name: "mkl" },
 { id: 9, name: "melast" },
 { id: 9, name: "imlast" },
 { id: 10, name: "glow" }
]
console.log(arr.distinct(obj => obj.id))

const arr = [
 { id: 1, name: "king" },
 { id: 2, name: "master" },
 { id: 3, name: "lisa" },
 { id: 4, name: "ion" },
 { id: 5, name: "jim" },
 { id: 6, name: "gowtham" },
 { id: 1, name: "jam" },
 { id: 1, name: "lol" },
 { id: 2, name: "kwick" },
 { id: 3, name: "april" },
 { id: 7, name: "sss" },
 { id: 8, name: "brace" },
 { id: 8, name: "peiter" },
 { id: 5, name: "hey" },
 { id: 6, name: "mkl" },
 { id: 9, name: "melast" },
 { id: 9, name: "imlast" },
 { id: 10, name: "glow" }
]

ARRAY limit()

console.log(JSON.stringify(arr.limit(2))) ;//get giới hạn 2 records

Output

[
    {"id":1,"name":"king"},
    {"id":2,"name":"master"}
]

ARRAY skip()

console.log(JSON.stringify(arr.skip(2))) ;//bỏ qua 2 records đầu tiên

[
    {"id":3,"name":"lisa"},
    {"id":4,"name":"ion"},
    {"id":5,"name":"jim"},
    {"id":6,"name":"gowtham"},
    {"id":1,"name":"jam"},
    {"id":1,"name":"lol"},
    {"id":2,"name":"kwick"},
    {"id":3,"name":"april"},
    {"id":7,"name":"sss"},
    {"id":8,"name":"brace"},
    {"id":8,"name":"peiter"},
    {"id":5,"name":"hey"},
    {"id":6,"name":"mkl"},
    {"id":9,"name":"melast"},
    {"id":9,"name":"imlast"},
    {"id":10,"name":"glow"}
]

let mycar = {make: 'Honda', model: 'Accord', year: 1998}
'make' in mycar  // returns true
'model' in mycar // returns true

const byteSize = str => new Blob([str]).size;

byteSize('😀'); // 4
byteSize('Hello World'); // 11

const capitalize = ([first, ...rest]) =>
  first.toUpperCase() + rest.join('');
  
capitalize('fooBar'); // 'FooBar'
capitalize('fooBar', true); // 'Foobar'

const capitalizeEveryWord = str => str.replace(/\b[a-z]/g, char => char.toUpperCase());

capitalizeEveryWord('hello world!'); // 'Hello World!'

// REQUEST TIME OUT
const timeout = (prom, time) =>
	Promise.race([prom, new Promise((_r, rej) => setTimeout(rej, time))]);
// resolves in 500 ms
const fn = async () => {
	await new Promise((res) => setTimeout(res, 500));
	return "p2";
}

// finishes before the timeout
const result = await timeout(fn(), 1000);
// result = p2

// timeouts in 100 ms
await timeout(fn(), 100);
// error
// END

// EXAMPLE HIGH ORDER Function

var grades = [
    {name: 'John', grade: 8, sex: 'M'},
    {name: 'Sarah', grade: 12, sex: 'F'},
    {name: 'Bob', grade: 16, sex: 'M'},
    {name: 'Johnny', grade: 2, sex: 'M'},
    {name: 'Ethan', grade: 4, sex: 'M'},
    {name: 'Paula', grade: 18, sex: 'F'},
    {name: 'Donald', grade: 5, sex: 'M'},
    {name: 'Jennifer', grade: 13, sex: 'F'},
    {name: 'Courtney', grade: 15, sex: 'F'},
    {name: 'Jane', grade: 9, sex: 'F'}
]

let isBoy = student => student.sex === 'M'

let isGirl = student => student.sex === 'F'

let getBoys = grades => (
    grades.filter(isBoy)
)

let getGirls = grades => (
    grades.filter(isGirl)
)

let average = grades => (
    grades.reduce((acc, curr) => (
        acc + curr.grade
    ), 0) / grades.length
)

let maxGrade = grades => (
    Math.max(...grades.map(student => student.grade))
)

let minGrade = grades => (
    Math.min(...grades.map(student => student.grade))
)

let classroomAverage = average(grades) // 10.2
let boysAverage = average(getBoys(grades)) // 7
let girlsAverage = average(getGirls(grades)) // 13.4
let highestGrade = maxGrade(grades) // 18
let lowestGrade = minGrade(grades) // 2
let highestBoysGrade = maxGrade(getBoys(grades)) // 16
let lowestBoysGrade = minGrade(getBoys(grades)) // 2
let highestGirlsGrade = maxGrade(getGirls(grades)) // 18
let lowestGirlsGrade = minGrade(getGirls(grades)) // 9

Promise.prototype.finally

let isLoading = true;

fetch(myRequest).then(function(response) {
    var contentType = response.headers.get("content-type");
    if(contentType && contentType.includes("application/json")) {
      return response.json();
    }
    throw new TypeError("Oops, we haven't got JSON!");
  })
  .then(function(json) { /* process your JSON further */ })
  .catch(function(error) { console.log(error); })
  .finally(function() { isLoading = false; });

 rm -rf node_modules/
 arr = [1, 2, 3, 4, 6]
arr.splice(4, 0, 5)
 => arr = [0, 1, 2, 3, 4, 5, 6];
 
 let cr7 = {
    job: 'football',
    age: 36,
    hobbies: ['massage', 'game'],
    clubs: ['mu', 'juve','real'],
    height: '188cm',
    childs: 5
};

let { age, childs, ...replicant } = cr7;
=> replicant = cr7 = {
    job: 'football',
    hobbies: ['massage', 'game'],
    clubs: ['mu', 'juve','real'],
    height: '188cm',
};
 
 path multiple url issue => package.json : homepage:"",
 
 match();
 
const quote =  "If you don't know where you are going, any road will get you there.";
console.log(quote.match(/you/g)) // [ "you", "you", "you" ];

Regx phone number
/^(0?)(3[2-9]|5[6|8|9]|7[0|6-9]|8[0-6|8|9]|9[0-4|6-9])[0-9]{7}$/

Empty headers request:
axios.get("http://api.com", {
        headers:{ Authorization:""}
});
var headers = {
        'Content-Type': 'application/json',
        'Authorization': '' 
}
 axios({
  method: 'post', //you can set what request you want to be
  url: 'https://example.com/request',
  data: {id: varID},
  headers: {
    Authorization: ''
  }
})
const array  = [5,4,7,8,9,2];
Sum
array.reduce((a,b) => a+b);
// Output: 35
Max
array.reduce((a,b) => a>b?a:b);
// Output: 9
Min
array.reduce((a,b) => a<b?a:b);
// Output: 2

Handle Call Back URL
callBackURL = 'https....'
const decode = decodeURIComponent(callBackURL)
const url = getQueryParams(decode).token
External link
window.location.href = url

// Assuming "?post=1234&amp;action=edit"

var urlParams = new URLSearchParams(window.location.search);

console.log(urlParams.has('post')); // true
console.log(urlParams.get('action')); // "edit"
console.log(urlParams.getAll('action')); // ["edit"]
console.log(urlParams.toString()); // "?post=1234&amp;action=edit"
console.log(urlParams.append('active', '1')); // "?post=1234&amp;action=edit&amp;active=1"

CHECK ONLINE USER
window.addEventListener('load', function() {
  var status = document.getElementById("status");
  var log = document.getElementById("log");

  function updateOnlineStatus(event) {
    var condition = navigator.onLine ? "online" : "offline";

    status.className = condition;
    status.innerHTML = condition.toUpperCase();

    log.insertAdjacentHTML("beforeend", "Event: " + event.type + "; Status: " + condition);
  }

  window.addEventListener('online',  updateOnlineStatus);
  window.addEventListener('offline', updateOnlineStatus);
});

TURN Collection => config Object
function objFromArray(array, key = 'id') {
  return array.reduce((accumulator, current) => {
    accumulator[current[key]] = current;
    return accumulator;
  }, {});
}

const players = ["Cr7", "LM10", "Ney10"];

const photocopy = player => {
	return `${player} đang chơi cho đội nào vậy`
}

players.map(photocopy) => ["Cr7 đang chơi cho team nào vậy", "LM10 đang chơi cho team nào vậy", "Ney10 đang chơi cho team nào vậy"]

const users = [{
    name: 'Ronaldo',
    age: 23
}, {
    name: 'Messi',
    age: 14
}, {
    name: 'Anoystick',
    age: 22
}];

users.reduce((acc, { name, age }) => {
    return (age > 18) ? [...acc, name] : acc;
} , []) => ["Ronaldo", "Anoystick"];

const defaultTxt = 'Làm gì đây ở đây';
const textOptions = {
    citation: 'Bạn nhân được một tin nhắn từ {{actingUser}}.',
    follow:   '{{actingUser}} bắt đầu theo dõi bạn',
    mention:  '{{actingUser}} nhắc bạn trong một bài viết',
}
function getNotificationPtrn(textOptions, n) {
    return textOptions[n.type] || defaultTxt;
}
const notificationPtrn = getNotificationPtrn(textOptions, notification);

  Array.prototype.indexOfPropValue = function (prop, value) {
    for (var i = 0; i < this.length; ++i) {
      if (this[i][prop]) {
        if (this[i][prop] === value) {
          return i;
        }
      }
    }
    return -1;
  };

const ARR = [
			{"doCode": "AnXXX"},
			{"doCode": "TuanXXX"}
			];
const r = {"doCode": "TuanXXX"};
const indx =  ARR.indexOfPropValue("doCode", r.doCode) => 1;

Array.prototype.objFromArray = function(prop) {
      const key = prop || 'id'
      return  this.reduce((acc, i) => {
         acc[i[key]] = i
        return acc
}, {})
}
const AR = [
			{name: "Cr7", club: 'MU', id: 999},
			{name: "LM30", club: 'PSG', id: 1000},
			{name: "NY10", club: 'PSG', id: 995}
			];
AR.objFromArray('id') => {
    "995": {
        "name": "NY10",
        "club": "PSG",
        "id": 995
    },
    "999": {
        "name": "Cr7",
        "club": "MU",
        "id": 999
    },
    "1000": {
        "name": "LM30",
        "club": "PSG",
        "id": 1000
    }
}
TURN FLOAT => INT
~~5.25423423 === 5

CREATE A PROMISE FUNCTION

const myPromise = new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve('foo');
  }, 300);
});
let done = true

const isItDoneYet = new Promise((resolve, reject) => {
  if (done) {
    const workDone = 'Here is the thing I built'
    resolve(workDone)
  } else {
    const why = 'Still working on something else'
    reject(why)
  }
})

const checkIfItsDone = () => {
  isItDoneYet
    .then(ok => {
      console.log(ok)
      console.log('goal')
    })
    .catch(err => {
      console.error(err)
    })
}
checkIfItsDone()


const arr = [{d: 1, c: 2}, {d: 2, c: 3}, {d: 1, c: 2}, {d:2, c:3}, {d:4, c: 5}]
const uniqueAr = uniqBy(a, JSON.stringify) => import uniqBy from 'lodash/uniqBy';

VANILA JS

const uniqArr = (a, key) => {
    let seen = new Set();
    return a.filter(item => {
        let k = key(item);
        return seen.has(k) ? false : seen.add(k);
    });
}

NEW MAP

const actions = new Map([
  ['1', ['processing']],
  ['2', ['fail']],
  ['3', ['fail']],
  ['4', ['success']],
  ['5', ['cancel']],
  ['default', ['other']]
])

const clickHandler = (status) => {
  let action = actions.get(status) || actions.get('default')
  sendLog(action[0])
}

Array.prototype.findAndRemove = function (value, key = null) {
    const index = this.findIndex(obj => (!!obj[key]) ? obj[key] === value : obj === value);
    return index >= 0 ? [
        ...this.slice(0, index),
        ...this.slice(index + 1)
    ] : this;
}

function limit(c){
    return this.filter((x,i)=>{
        if(i<=(c-1)){return true}
    })
}

Array.prototype.limit = limit;

console.log(JSON.stringify(arr.limit(2))) ;//get giới hạn 2 records

function skip(c){
    return this.filter((x,i)=>{
    if(i>(c-1)){return true}
    })
}

Array.prototype.skip = skip;

console.log(JSON.stringify(arr.skip(2))) ;//bỏ qua 2 records đầu tiên

MERGE KEY INTO OBJECT WITH CONDITION

const MANU = true;
const player = {
    name: 'cr7',
    age: 35,
    ... (MANU && {club: 'manu'})
} 


JAVASCRIPT HANDBOOK

// GET UNIQUE VALUES OF AN ARRAY
var j = [...new Set([1, 2, 3, 3])]
>> [1, 2, 3]

// FIND THE DIFF ELEMENT

const elementDiff = (arr1, arr2) => {
	const newAr = new Set(arr1)
	return arr1.filter(arr => !newAr.has(arr)))	
}

var heroes = ['Batman','Flash','Superman','Wolverine']
var justiceLeaque = elementDiff(heroes, ['Wolverine']);
console.log(justiceLeaque);
Output -->
[ 'Batman', 'Flash', 'Superman' ]

// FILTER BOOLEAN
To Filter Falsy values (0, null, undefined, null, false)
so this trick:
>> myArray
    .map(item => {
        // ...
    })
    // Get rid of bad values
    .filter(Boolean);
	=> the boolean values will be blowed away

// CREATE EMPTY OBJECT
let dict = Object.create(null);

// DICT.__PROTO__ === "UNDEFINED"
// NO OBJECT PROPERTIES EXIST UNTIL YOU 

// MERGE OBJECTS
const person = { name: 'David Walsh', gender: 'Male' };
const tools = { computer: 'Mac', editor: 'Atom' };
const attributes = { handsomeness: 'Extreme', hair: 'Brown', eyes: 'Blue' };

const summary = {...person, ...tools, ...attributes};
/*
Object {
  "computer": "Mac",
  "editor": "Atom",
  "eyes": "Blue",
  "gender": "Male",
  "hair": "Brown",
  "handsomeness": "Extreme",
  "name": "David Walsh",
}
*/
// GET QUERY STRING PARAMETER
URLSearchParams
var urlParams = new URLSearchParams(window.location.search);

console.log(urlParams.has('post')); // true
console.log(urlParams.get('action')); // "edit"
console.log(urlParams.getAll('action')); // ["edit"]
console.log(urlParams.toString()); // "?post=1234&action=edit"
console.log(urlParams.append('active', '1')); // "?post=1234&action=edit&active=1"

// SHORT-CIRCUIT EVALUATION

return (foo || []).length;

If the variable foo is truthy, it will be returned. Otherwise, the length of the empty array will be returned: 0 .

return (this.state.data || 'Fetching Data');

// CONVERT TO STRING

const val = 1 + "";
console.log(val); // Result: "1"
console.log(typeof val); // Result: "string"

// QUICK FLOAT TO INTEGER

console.log(23.9 | 0);  // Result: 23
console.log(-23.9 | 0); // Result: -23

//GET THE LAST ITEM(S) IN AN ARRAY

let array = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];
CONSOLE.LOG(ARRAY.SLICE(-1)); // RESULT: [9]
CONSOLE.LOG(ARRAY.SLICE(-2)); // RESULT: [8, 9]
CONSOLE.LOG(ARRAY.SLICE(-3)); // RESULT: [7, 8, 9]

// SPLICE AND SPLICE AND SPLIT

SPLICE IS MUTABLE METHOD
arr = [1, 2, 3, 1]
example: arr.splice(1, arr.length - 1)
=> arr: [2, 3, 1]
add element syntax: array.splice(index, number of elements, element)
delete element syntax: array.splice(index, number of elements)

SLICE IS IMMUTABLE METHOD
arr  = [1, 2, 3, 1, 2]
example: let newArr = arr.slice(0, 3)
=> newArr: [1, 2, 3], arr: [1, 2, 3, 1, 2]

SPLIT 
SPLIT IS IMMUTABLE METHOD
SPLIT IS SPLIT STRING INTO SUBSTRINGS AND RETURN IT AS A ARRAy

FOREACH , MAP

FOREACH IS MUTABLE METHOD
MAP IS IMMUTABLE METHOD

// DELETE ELEMENT IN ARRAY

let index = arr.indexOf(val)

index > 1 && arr.splice(index, 1)

const deviceName = person?.device?.name;

// MERGE ARRAY 

const arr1 = [1, 2, 3]
const arr2 = [4,5,6]
const array = [...arr1,...arr2]

let newArray = Array(3).fill('')
console.log(newArray) => ['', '', '']

//REACT 
this.setState({ // set state }, () => {execute function here or this is call back})
._lodash
._pickBy(data, ._identity) => this is lodash'method is eleminate all falsy value in data

// SUBSTRING
array.substring(start, end) => (not include end index)
example: req.file.path : public\uploads\b14c9d87c7455a6768ffea73c19d6e32
let fileurl = req.file.path.replace(/\\/g, "/") => public/uploads/b14c9d87c7455a6768ffea73c19d6e32
fileurl.substrings("public".length)

// CACHE

// PROGRESSIVE WEB APP

// PAGINATION SUMMARY

CHECKING EXISTENT PROPERTIES IN 2020

function getAppleExpirationDate(obj) {
  if (food.fruits && food.fruits.apple && food.fruits.apple.dates) {
    return food.fruits.apple.dates.expired
  }
}

==> BETTER WAY

function getAppleExpirationDate(obj) {
  return food?.fruits?.apple?.dates?.expired
}

// EVERY METHOD ARRAY
 const arr = [1,2,3,4,5,6,7,8,9,10]
 arr.every(n => n > 6) => false
 arr.every(n => n > 0) => true
 
 const withtab = JSON.stringify(example, ["student", "firstName", "lastName"], '\t')
 
 ==> this is result
 
 "student" : [
	{
		"firstName": "Tom",
		"lastName": "Hank"
	},
	{
		"firstName": "Ryan",
		"lastName": "Gosling"
	}
 ]
 
 distance between days
 let a= moment()
 let b= moment()
 a.dff(b, "days")
 // 
 let objectA = {
	'name': 'AN',
 }
 
 Object.keys(objectA) => ['name']
 
 // prevent click
 
 onClick = (event) => {
	event.stopPropagation()
 } 
 
 // Concat with conditions
 
 let [productstock, countProductstock, countTotal] = await Promise.all([
      sails.sendNativeQuery(this.req, PRODUCT_STOCK_SQL),
      sails.sendNativeQuery(this.req, COUNT_PRODUCT_SQL)
    ].concat((limit && skip === 0 ? [sails.sendNativeQuery(this.req, TOTAL_PRODUCT_STOCK_SQL)] : [])))

//Example SQL with add, select and where conditions

ALTER TABLE `stock` ADD (
  `newStockId` double DEFAULT NULL,
  `currentStockId` double DEFAULT NULL
); => add column into table `stock`

set @newStockId = (select id from `stock` where `deletedAt` = 0 limit 1);
update `stock` set newStockId = @newStockId where newStockId is null and deletedAt <> 0;
update `stock` set currentStockId = @newStockId where currentStockId is null and deletedAt <> 0;
=> set update with conditions and temp value

// includes method javascript - lodash

syntax: _.includes(collection, value, [fromIndex=0])

Example

_.includes([1, 2, 3], 1);
// => true
 
_.includes([1, 2, 3], 1, 2);
// => false
 
_.includes({ 'a': 1, 'b': 2 }, 1);
// => true
 
_.includes('abcd', 'bc');
// => true

// Convert string array into Array

Example:

let stringArray = "[1, 2]"

string array => array

let realArray = JSON.parse(stringArray)

FILTER TWO ARRAY WITH COMMONS VALUES

var array1 = ['apples', 'grapes', 'oranges', 'banana'],
  array2 = ['potato', 'pears', 'grapes', 'berries', 'apples', 'oranges'];

var intersection = array1.filter(function(e) {
  return array2.indexOf(e) > -1;
});

console.log(intersection);
Trivia notes:

EVERYTHING CREATED IN JAVASCRIPT IS EITHER A PRIMITIVE OR AN OBJECT. THEREFORE, IF IT ISN'T ONE OF THOSE SEVEN PRIMITIVES, SO IT'S AN OBJECT

// OBJECT FROM ENTRIES

const keyValuePair = [
  ['cow', 'Bo'],
  ['pig', 'Heo'],
];

Object.fromEntries(keyValuePair); => result: // { cow: Bo pig: Heo }

const map = new Map([
  ['key 1', 'value 1'],
  ['key 2', 'value 2'],
]);

// USING THE CONSTRUCTOR
const map = new Map([
  ['key 1', 'value 1'],
  ['key 2', 'value 2'],
]);
// OR WE CAN USE THE INSTANCE METHOD, "SET"
const map = new Map();
map.set('key 1', 'value 1');
map.set('key 2', 'value 2');
// RESULT
// Map(2) {"key 1" => "value 1", "key 2" => "value 2"}

OBJECT.FROMENTRIES(MAP) => // { KEY 1: "VALUE 1", KEY 2: "VALUE 2"}
MAKE SURE YOU ONLY PASS A KEY-VALUE PAIR 

Object.fromEntries vs Object.entries

const object = { key1: 'value1', key2: 'value2' };
const array = Object.entries(object);
// [ ["key1", "value1"], ["key2", "value2"] ]
Object.fromEntries(array);
// { key1: 'value1', key2: 'value2' }

const food = { meat: 'ðŸ¥©', broccoli: 'ðŸ¥¦', carrot: 'ðŸ¥•' };
// ðŸ˜„ Yay, still in Object land
const vegetarian = Object.fromEntries(
  Object.entries(food).filter(([key, value]) => key !== 'meat'),
);
// { broccoli: 'ðŸ¥¦', carrot: 'ðŸ¥•' }

// NULLISH COALESCING

false ?? "default string"
=> result: false

NaN ?? "default string"
=> result: NaN

0 ?? "default string"
=> 0

null ?? "default string"
=> "default string"

undefined ?? "default string"
=> "default string" 

String#matchAll

const regexp = /[a-c]/g
const str = 'ab'
const iterator = str.matchAll(regexp)

Array.from(iterator, result => console.log(result))

=> ["a", index: 0, input: "abc", group: undefined ]

=> ["b", index: 1, input: "abc", group: undefined ]

// 
<input type="checkbox" id="check_me" ref="checked_now" />

GET VALUE OF THIS INPUT FROM ANOTHER DOM

example

let a = this.refs.checked_now.checked (this.refs.checked_now.value)

GET VALUE THROUGH GETELEMENTBYID

<input type="text" id="text_me" ref="text-box" />

let text = document.getElementbyID("text_me").value

UPDATE VALUE THROUGH GETELEMENTBYID

<input type="checkbox" id="check_me" ref="checked_now" />

document.getElementbyID("check_me").checked = true 

OR

document.getElementbyID("check_me").checked = false

CHECK NULL VALUE

let bar = null 

console.log(Array.isArray(bar));

CLOSURE Example: 

for (var i = 0; i < 5; i++) {
	setTimeout(function() { console.log(i); }, i * 1000 );
}

=> result is 5, 5, 5, 5

for (let i = 0; i < 5; i++) {
	setTimeout(function() { console.log(i); }, i * 1000 );
}

=> result is 0, 1, 2, 3, 4

JavaScript currently has eight data types:

number
bigint
string
boolean
null
undefined
object
symbol

Querying the DOM

document.getElementsByClassName('class name')
document.querySelectorAll('.class name')

// CLOSURE Example:  (continue)

function showName (first, last) {
    let name = "my name is ";
    let asd = 'asd'
    function fullName() { ==> this is inner function
        console.log(asd); ==> variable from outer function
        console.log(name + first + " " + last) 
    }
    return fullName()
}

showName('an', 'nguyen')

ASYNCHRONOUS

An asynchronous model allows multiple things to happen at the same time. When you start an action, your program continues to run.
When the action finishes, the program is informed and gets access to the result (for example, the data read from disk).

DIFFERENCE BETWEEN PROMISE AND ASYNC/AWAIT

ASYNC/AWAIT makes your code leaner and fresher

PROMISE
const makeRequest = () => {
  return getJSON()
    .then(data => {
      if (data.needsAnotherRequest) {
        return makeAnotherRequest(data)
          .then(moreData => {
            console.log(moreData)
            return moreData
          })
      } else {
        console.log(data)
        return data
      }
    })
} ===> have 6 level nested together => look like hell

ASYNC/AWAIT

const makeRequest = async () => {
  const data = await getJSON()
  if (data.needsAnotherRequest) {
    const moreData = await makeAnotherRequest(data);
    console.log(moreData)
    return moreData
  } else {
    console.log(data)
    return data    
  }
} ==> cleaner and easy to debug

EASY to debug with ASYNC/AWAIT

can't set break point into promise function

example

const makeExample = () => {
	return allPromiseApi()
		.then(() => allPromiseApi)
		.then(() => allPromiseApi)
		.then(() => allPromiseApi)
		.then(() => allPromiseApi)
} ==> debug is become impossible

Break point with ASYNC/AWAIT too easy

DATA STUCTURE IN JAVASCRIPT

Queues
=> FIFO: First In First Out

Stack
=> FILO: First In Last Out

Trees

Graphs

Hash Map

REDUX

Data flow of application is too complicated

Use for Component interact each other, not parent/child Component

LOCAL STORAGE VS SESSION STORAGE VS COOKIE

LOCAL STORAGE

- LocalStorage is a way to store data on the clientâ€™s computer.
- It allows the saving of key/value pairs in a web browser and it stores data with no expiration date.
- However, the user has the ability to clear the browser data/cache to erase all localStorage data.
- Data is never transferred to the server

SESSION STORAGE

- Stores data only for a session, meaning that the data is stored until the browser (or tab) is closed
- Data is never transferred to the server
- Can only be read on client-side
- Storage limit is about 5-10MB
- Opening multiple tabs/windows with the same URL creates sessionStorage for each tab/window

COOKIE

- Cookies are primarily for server-side reading (can also be read on client-side), localStorage and sessionStorage can only be read on client-side.
- Size must be less than 4KB.
- Cookies can be made secure by setting the httpOnly flag as true for that cookie. This prevents client-side access to that cookie.
- Can read, write, delete with document.cookie

WHATâ€™S THE DIFFERENCE BETWEEN UNDEFINED AND NULL?

undefined is the value for undeclared variables

null equals undefined when compared with the == operator . => this is all falsy
They arenâ€™t equal when we compare them with the === operator since theyâ€™re of different types.

STATE 

The state is a data structure that starts with a default value when a Component mounts. It may be mutated across time, mostly as a result of user events

PROPS

Props (short for properties) are a Componentâ€™s configuration. Props are how components talk to each other.
They are received from above component and immutable as far as the Component receiving them is concerned.
Props do not have to just be data â€” callback functions may be passed in as props.

PROPS and STATE do similar things but are used in different ways. The majority of our components will probably be stateless. 
Props are used to pass data from parent to child or by the component itself.
They are immutable and thus will not be changed. State is used for mutable data, or data that will change.
This is particularly useful for user input.

maxItemOfArray

const maxItemOfArray = (arr) => [â€¦arr].sort((a, b) => b â€” a).slice(0, 1)[0];
let maxItem = maxItemOfArray([3, 5, 12, 5]);

areAllEqual

const areAllEqual = array => array.every(item => item === array[0]);
let check1 = areAllEqual([3, 5, 2]); // false
let check2 = allEqual([3, 3, 3]); // true

averageOf

const averageOf = (â€¦numbers) => numbers.reduce((a, b) => a + b, 0) / numbers.length;
let average = averageOf(5, 2, 4, 7); // 4.5

findAndReplace

const findAndReplace = (string, wordToFind, wordToReplace) => string.split(wordToFind).join(wordToReplace);
let result = findAndReplace(â€˜I like bananaâ€™, â€˜bananaâ€™, â€˜appleâ€™); // I like apple




removeDuplicatedValues

const removeDuplicatedValues = array => [â€¦new Set(array)];
let arr = removeDuplicatedValues([5, 3, 2, 5, 6, 1, 1, 6]); // [5, 3, 2, 6, 1]

getTimeFromDate

const getTimeFromDate = date => date.toTimeString().slice(0, 8);
let time = getTimeFromDate(new Date()); // 09:46:08

capitalizeAllWords

const capitalizeAllWords = str => str.replace(/\b[a-z]/g, char => char.toUpperCase());
let str = capitalizeAllWords(â€˜i love reading bookâ€™); // I Love Reading Book

LODASH

	1. _.assign

	var foo = { a: "a property" };
	var bar = { b: 4, c: "an other property" }

	var result = _.assign({ a: "an old property" }, foo, bar);
	// result => { a: 'a property', b: 4, c: 'an other property' }

	2. _.times

	function getRandomInteger() {
		return Math.round(Math.random() * 100);
	}

	var result = _.times(5, getRandomNumber);
	// result => [64, 70, 29, 10, 23]

	3. _.debounce

	function validateEmail() {
		// Validate email here and show error message if not valid
	}

	var emailInput = document.getElementById("email-field");
	emailInput.addEventListener("keyup", _.debounce(validateEmail, 500));

	4. _.find


	var users = [
	  { firstName: "John", lastName: "Doe", age: 28, gender: "male" },
	  { firstName: "Jane", lastName: "Doe", age: 5, gender: "female" },
	  { firstName: "Jim", lastName: "Carrey", age: 54, gender: "male" },
	  { firstName: "Kate", lastName: "Winslet", age: 40, gender: "female" }
	];

	var user = _.find(users, { lastName: "Doe", gender: "male" });
	// user -> { firstName: "John", lastName: "Doe", age: 28, gender: "male" }

	var underAgeUser = _.find(users, function(user) {
		return user.age < 18;
	});
	// underAgeUser -> { firstName: "Jane", lastName: "Doe", age: 5, gender: "female" }

	5. _.get and ._set
		
	var bar = { foo: { key: "foo" } };
	_.set(bar, "foo.items[0]", "An item");
	// bar => { foo: { key: "foo", items: ["An item"] } }
	var name = _.get(bar, "name", "John Doe");
	// name => John Doe
	
	6. _.deburr
	
	_.deburr("dÃ©jÃ  vu");
	// -> deja vu
	_.deburr("Juan JosÃ©");
	// -> Juan Jose	
	
	7. _.keyBy
	
	var posts = [
    { id: "1abc", title: "First blog post", content: "..." },
    { id: "2abc", title: "Second blog post", content: "..." },
    // more blog posts
    { id: "34abc", title: "The blog post we want", content: "..." }
    // even more blog posts
	];

	posts = _.keyBy(posts, "id");

	var post = posts["34abc"]
	// post -> { id: "34abc", title: "The blog post we want", content: "..." }
	
	8. _.reduce
	
	var users = [
    { name: "John", age: 30 },
    { name: "Jane", age: 28 },
    { name: "Bill", age: 65 },
    { name: "Emily", age: 17 },
    { name: "Jack", age: 30 }
	]

	var reducedUsers = _.reduce(users, function (result, user) {
		if(user.age >= 18 && user.age <= 59) {
			(result[user.age] || (result[user.age] = [])).push(user);
		}
	  
		return result;
	}, {});

	// reducedUsers -> { 
	//     28: [{ name: "Jane", age: 28 }], 
	//     30: [{ name: "John", age: 30 }, { name: "Jack", age: 30 }] 
// }
	
	9. _.cloneDeep
	
	var original = { foo: "bar" };
	var copy = original;
	copy.foo = "new value";
	// copy -> { foo: "new value" } Yeah!
	// original -> { foo: "new value" } Oops!

	var original = { foo: "bar" };
	var copy = _.cloneDeep(original);
	copy.foo = "new value";
	// copy -> { foo: "new value" } Yeah!
	// original -> { foo: "bar" } Yeah!
	
	10 _. sortedUniq
		
	var sortedArray = [1, 1, 2, 3, 3, 3, 5, 8, 8];
	var result = _.sortedUniq(sortedArray);
	// -> [1, 2, 3, 5, 8]
	
High-Order Function

let colors = ["red", "green", "blue"]

colors.forEach(myFavColor)

function myFavColor(color) {
	console.log(`the color ${color} is my favorite color`)
}





